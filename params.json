{
  "name": "大変革",
  "tagline": "Homebrew, mods, plugins, and more",
  "body": "## The next step\r\n\r\ntaiHENkaku is everything you know and love about [HENkaku](https://henkaku.xyz/) and more. Just like before, you can run your favorite homebrew games, emulators, and tweaks. However, this update brings the addition of plugins as well. Based off of technology similar to [Cydia Substrate](http://www.cydiasubstrate.com) (specifically thanks to [substitute](https://github.com/comex/substitute)), taiHEN allows developers to write hooks and patches to remix games, system applications, and the kernel.\r\n\r\n## Getting started\r\n\r\nWe are still ironing out some issues but you can try an early beta today! Just visit **http://beta.henkaku.xyz/** from your PS Vita device to try out the new release. If you wish to wait or go back to the last stable release, just reboot your console and visit the old site, **https://henkaku.xyz/**.\r\n\r\nPlease note that currently, the beta is only recommended for developers who wish to test out their own taiHEN plugins. We still recommend the last stable release for everyone else because while we rewrote HENkaku from the ground up to use the new patch system, it does not introduce any new features for the user (and does introduce new instabilities). We hope that developers will use taiHEN to write new mods that would work with taiHENkaku and any future exploits!\r\n\r\n## Developers\r\n\r\nCalling all developers! We need you to create some awesome new tweaks using taiHEN! With the new hooking system, the possibilities are endless: cheats, UI tweaks, screen casting, and more. But we need your help is making it all a reality. Get started by downloading the latest kernel enabled [toolchain](https://github.com/vitasdk/buildscripts) and the taiHEN library from the links to the right. Check out the [API documentation](/docs/) for taiHEN. Join us in the [#vitasdk](irc://chat.freenode.net/vitasdk) chatroom in FreeNode IRC for help and support.\r\n\r\n### Building\r\n\r\nWe will add build instructions for plugins here in the future. Right now, just check out how the [HENkaku plugin](https://github.com/henkaku/henkaku/plugin/tree/master/src) does it or chat with us in [#vitasdk](irc://chat.freenode.net/vitasdk).\r\n\r\n### Configuration\r\n\r\nThe configuration that determines the plugins to load and the load order can be found in `ux0:tai/config.txt`. The format is very simple and self explanatory.\r\n\r\n```text\r\n# ignored line starting with #\r\n# Kernel plugins are started with taiHEN and are in this section\r\n*KERNEL\r\nux0:app/MLCL00001/henkaku.skprx\r\nux0:path/to/another.skprx\r\nux0:tai/plugin3.skprx\r\nux0:data/tai/plugin4.skprx\r\nux0:data/tai/plugin5.skprx\r\n# titleid for SceSettings\r\n*NPXS10015\r\nux0:app/MLCL00001/henkaku.suprx\r\nux0:data/tai/some_settings_plugin.suprx\r\n# titleid for Package Installer\r\n*NPXS10031\r\nux0:path/to/some_pkg_installer_plgin.suprx\r\n# titleid for SceShell is special (does not follow the XXXXYYYYY format)\r\n*main\r\nux0:app/MLCL00001/henkaku.skprx\r\nux0:data/tai/shell_plgin.skprx\r\n```\r\n\r\nThe key things to note are\r\n\r\n1. `#` begins a comment, `*` begins a section, and any other character begins a path.\r\n2. `KERNEL` is a special section name denoting to load a kernel plugin when taiHEN is started up. All other section names are the title id of the application/game in which to load the plugin at startup. Note that SceShell has a special title id of `main`.\r\n3. In each section, there is a list of plugin paths that will be loaded in order. Paths can be anywhere but it is recommended that plugins reside in `ux0:tai` or `ux0:data/tai`. It is valid to have one plugin in multiple sections but the developer must ensure that the plugin knows which application it is loaded in if it needs to do things differently.\r\n\r\n### Examples\r\n\r\nWe hope you will read the [API documentation](/docs/) to see the full power of taiHEN and the [HENkaku source](https://github.com/henkaku/henkaku/plugin/tree/master/src) to see an example usage. However, below are some quick usage examples that demonstrate the power of taiHEN.\r\n\r\n#### Do something on startup\r\n\r\nThis user plugin will be configured to load on an application named \"AppName.\"\r\n\r\n```c\r\n// handle to our hook\r\nstatic tai_hook_ref_t app_start_ref;\r\n// our hook for app entry\r\nint hook_app_start(SceSize argc, const void *args) {\r\n  printf(\"hello world!\\n\");\r\n  return TAI_CONTINUE(int, app_start_ref, argc, args);\r\n}\r\n// our own plugin entry\r\nint module_start(SceSize argc, const void *args) {\r\n  taiHookFunctionExport(&app_start_ref,  // Output a reference\r\n                        \"AppName\",       // Name of module being hooked\r\n                        TAI_ANY_LIBRARY, // If there's multiple libs exporting this\r\n                        0x935CD196,      // Special NID specifying `module_start`\r\n                        hook_app_start); // Name of the hook function\r\n  return SCE_KERNEL_START_SUCCESS;\r\n}\r\n```\r\n\r\n#### Logging Filesystem\r\n\r\nThis plugin will be configured to load in kernel.\r\n\r\n```c\r\n// handle to our hook\r\nstatic tai_hook_ref_t open_ref;\r\n// this function is in kernel space\r\nSceUID hook_user_open(const char *path, int flags, SceMode mode, void *args) {\r\n  char k_path[256];\r\n  SceUID fd;\r\n  fd = TAI_CONTINUE(SceUID, open_ref, path, flags, mode, args);\r\n  // we need to copy the user pointer to kernel space\r\n  sceKernelStrncpyUserToKernel(k_path, (uintptr_t)path, 256);\r\n  // do some logging\r\n  printf(\"opening: %s, res: %x\\n\", k_path, fd);\r\n  return fd;\r\n}\r\n// plugin entry\r\nint module_start(SceSize argc, const void *args) {\r\n  taiHookFunctionExportForKernel(KERNEL_PID,      // Kernel process\r\n                                 &open_ref,       // Output a reference\r\n                                 \"SceIofilemgr\",  // Name of module being hooked\r\n                                 TAI_ANY_LIBRARY, // If there's multiple libs exporting this\r\n                                 0xCC67B6FD,      // NID specifying `sceIoOpen`\r\n                                 hook_user_open); // Name of the hook function\r\n  return SCE_KERNEL_START_SUCCESS;\r\n}\r\n```\r\n\r\n#### Chain of hooks\r\n\r\nConsider one kernel plugin with the code above. Now consider a second kernel plugin as follows.\r\n\r\n```c\r\n// handle to our hook\r\nstatic tai_hook_ref_t another_open_ref;\r\n// this function is in kernel space\r\nSceUID hook_user_open_differently(const char *path, int flags, SceMode mode, void *args) {\r\n  char k_path[256];\r\n  SceUID fd;\r\n  fd = TAI_CONTINUE(SceUID, another_open_ref, path, flags, mode, args);\r\n  // we need to copy the user pointer to kernel space\r\n  sceKernelStrncpyUserToKernel(k_path, (uintptr_t)path, 256);\r\n  // filter out certain paths\r\n  if (strcmp(k_path, \"ux0:hidden_file.bin\") == 0 && fd >= 0) {\r\n    sceIoClose(fd); // close the handle\r\n    fd = SCE_KERNEL_ERROR_NOENT;\r\n  }\r\n  return fd;\r\n}\r\n// another plugin entry\r\nint module_start(SceSize argc, const void *args) {\r\n  taiHookFunctionExportForKernel(KERNEL_PID,                  // Kernel process\r\n                                 &another_open_ref,           // Output a reference\r\n                                 \"SceIofilemgr\",              // Name of module being hooked\r\n                                 TAI_ANY_LIBRARY,             // If there's multiple libs exporting this\r\n                                 0xCC67B6FD,                  // NID specifying `sceIoOpen`\r\n                                 hook_user_open_differently); // Name of the hook function\r\n  return SCE_KERNEL_START_SUCCESS;\r\n}\r\n```\r\n\r\nNow we have both filesystem filtering _and_ logging.\r\n\r\n#### Enabling dynarec\r\n\r\nThis plugin will be loaded in kernel and changes the return value of a function that does a check to enable dynarec.\r\n\r\n```c\r\n// handle to our hook\r\nstatic tai_hook_ref_t some_sysroot_check_hook;\r\n// patch function\r\nstatic int some_sysroot_check_patched(void) {\r\n  // It is important that we always call `TAI_CONTINUE` regardless if we need \r\n  // the return value or not. This ensures other hooks in the chain can run!\r\n  TAI_CONTINUE(int, some_sysroot_check_hook);\r\n  return 1;\r\n}\r\n// plugin entry\r\nint module_start(SceSize argc, const void *args) {\r\n  taiHookFunctionExportForKernel(KERNEL_PID,                  // Kernel process\r\n                                 &some_sysroot_check_hook,    // Output a reference\r\n                                 \"SceSysmem\",                 // Name of module being hooked\r\n                                 0x3691DA45,                  // NID specifying `SceSysrootForKernel`\r\n                                 0xF8769E86,                  // NID of the export function we patch\r\n                                 some_sysroot_check_patched); // Name of the hook function\r\n  return SCE_KERNEL_START_SUCCESS;\r\n}\r\n```\r\n\r\n#### Local file logging\r\n\r\nThe above examples are all global hooks: every call regardless of origin will be hooked. You can also insert local hooks: a library import from a module. In this example, we have a user plugin loaded with \"AppName\" that only logs `sceIoOpen` calls from that application.\r\n\r\n```c\r\n// handle to our hook\r\nstatic tai_hook_ref_t local_open_hook;\r\n// this function is in user space now\r\nSceUID hook_local_open(const char *path, int flags, SceMode mode) {\r\n  SceUID fd;\r\n  fd = TAI_CONTINUE(SceUID, local_open_hook, path, flags, mode);\r\n  printf(\"open in AppName: %s, ret: %x\", path, fd);\r\n  return fd;\r\n}\r\n// our own plugin entry\r\nint module_start(SceSize argc, const void *args) {\r\n  taiHookFunctionImport(&local_open_hook,  // Output a reference\r\n                        \"AppName\",         // Name of module being hooked\r\n                        0xCAE9ACE6,        // NID specifying `SceLibKernel`, a wrapper library\r\n                        0x6C60AC61,        // NID specifying `sceIoOpen`\r\n                        hook_local_open);  // Name of the hook function\r\n  return SCE_KERNEL_START_SUCCESS;\r\n}\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}